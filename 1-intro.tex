\section{Introduction}
\label{sec:intro}

\david{BFT is popular but throughput is difficult to scale.}
Byzantine Fault Tolerant (BFT)~\cite{byzantineGenerals} protocols provide resilience against arbitrary machine failures, even if those machines conspire to sabotage the system.
Unfortunately, the intricate design of BFT protocols that enable them to survive Byzantine failures also contributes to their complexity.
This complexity prevents existing protocols from scaling to accommodate the higher throughput required by modern applications, while attempts to create new, scalable BFT protocols have been error-prone~\cite{zyzzyvaBug, protocolBugsList}.

\david{Chu et al. scales throughput but the rewrites introduce new nodes that can become Byzantine and alter the behavior of protocols.}
\sigmodpaper{}~\cite{autocomp} provides a new approach to scaling distributed protocols: instead of creating new protocols from scratch, the authors modify existing protocols by identifying a set of localized, rule-driven rewrites.
By manually applying the rewrites to various components of the voting protocol, 2PC, and Paxos~\cite{paxosComplex}, the authors improved throughput by $2-5\times$.
However, these rewrites were proven correct assuming non-Byzantine failures, and may not be safe when applied naively to BFT protocols.

\david{Provide example of unintuitive new vector of attack: partitioning}
Consider the following example of a protocol that contains a single-node, non-Byzantine 2P-Set~\cite{crdt}, a set where removed elements cannot be re-inserted.
Because individual keys in a 2P-Set are independent, according to \sigmodpaper{}, the 2P-Set can be partitioned by keyspace onto individual machines.
If Byzantine failures are possible, however, this partitioning would be \emph{unsafe}.
Originally, a Byzantine node within the protocol would be able to fabricate messages to this 2P-Set and either insert or remove elements, but the 2P-Set would still guarantee that once an element was marked as removed, it could never be inserted again.
After partitioning, a Byzantine node could force an item to be re-inserted by ignoring the partitioning scheme and duplicating the insertion message to multiple partitions.
Then, the Byzantine node could forward any queries on this 2P-Set to a partition of its choice and create the illusion that the 2P-Set is flip-flopping between whether an element has been removed or not.
In general, without modifications, the rewrites presented by \sigmodpaper{} are unsafe when applied to BFT protocols.
\david{Should we create a figure?}

This paper modifies the rewrites introduced by \sigmodpaper{} and proves their correctness when applied to BFT protocols.

\david{How the proofs are different.}
The difference in the proofs used by this paper and \sigmodpaper{} can be boiled down to the difference in what messages a correct machine can receive.
\sigmodpaper{} made two implicit assumptions in their rewrites that do not hold in a Byzantine environment:
(1) New machines will execute program logic as intended, and
(2) New input channels will be populated with the expected messages.

The first assumption is violated if a new machine becomes Byzantine.
We will show that the combined outputs of newly Byzantine machines is a subset of the possible outputs of the original Byzantine machines, so they do not form a stronger adversary.
In order to prove this property, we must carefully define what messages Byzantine machine is capable of sending.

The second assumption is violated if Byzantine machines attempt to violate the new input channels' invariants, like in the partitioning example presented earlier.
We will modify the rewrites such that nodes detect and discard any invariant-violating messages.