\section{Proofs of Correctness}
\label{sec:proofs}
We will now modify the rewrites presented by \sigmodpaper{} and prove their correctness in the presence of Byzantine failures.

\david{What the rewrites are.}
Broadly speaking, \sigmodpaper{} introduces new machines and message channels through decoupling and partitioning.
Decoupling splits logic on a single machine $l$ into two separate machine $l_1$ and $l_2$, which can be executed on separate machines and communicate through newly created message channels.
These newly created channels can potentially be exploited by Byzantine machines.
Partitioning splits data originally located on a single machine $l$ across many machines $l_1, l_2$, etc, each of which execute the same logic as $l$ but process disjoint sets of data.
An external machine that sent messages to $l$ before decoupling or partitioning must reroute or duplicate its messages to the correct $l_i$, which presents another exploitable invariant.

We assume the predefined functions will be modified after the rewrite as follows: \texttt{machines()} now contains the location of all machines post-rewrites, \texttt{isByzantine(l)} can be true for new machine locations, and for each machine location $l_i$ corresponding to the original machine $l$, \texttt{keys($l_i$) = keys($l$)}.

\david{What we have to demonstrate for correctness.}
We will assume for our proofs that the rewrites are correct when there are no Byzantine failures~\cite{autocomp} and that the protocol which is being rewritten is already Byzantine fault tolerant.
We will refer to Byzantine machines in the original protocol as \emph{old Byzantine machines} and those in the rewritten protocol as \emph{new Byzantine machines}.
In order to prove the rewrites safe under Byzantine failures, we must demonstrate the following:
New and old Byzantine machines are indistinguishable (\Cref{sec:new-machines-fault-tolerance}), and
any new assumptions made by message channels are enforced (\Cref{sec:byzantine-new-channels}).
\david{Should we introduce modifications to the rewrites in an earlier section, instead of combining it with the proofs?}


\subsection{Indistinguishability between new and old Byzantine machines}
\label{sec:new-machines-fault-tolerance}
We argue that a non-Byzantine machine cannot distinguish between a Byzantine machine $m$ and a Byzantine machine $m_i$, where $m_i$ is decoupled or partitioned from $m$.
We will first show that new and old Byzantine machines are equally powerful, then show that the number of failures in the system appears unchanged to all correct machines.


\subsubsection{Equivalent expressivity}
\label{sec:equivalent-expressivity}
Two Byzantine machines have the same expressivity if the set of messages they can output is the same.
Old and new Byzantine machines contain the same logic as defined in \Cref{sec:bft-formalism}; what separates them is the set of input channels in the original and rewritten protocol.
Because the rewrites modify and create new input channels, a new Byzantine machine that creates messages for (or forwards messages from) these input channels would be more powerful.
In this section, we will show that on input channels that are \emph{untouched by the rewrites}, any message sent by a new Byzantine machine either could have been sent by an old Byzantine machine or would be discarded by any non-Byzantine machine.
We will discuss messages to modified and newly created channels in \Cref{sec:byzantine-new-channels}, since the message types may have changed and we can no longer argue indistinguishability.


\david{Proof if there is no forwarding.}
For plaintext and signed message channels without forwarding, because all fields are generated randomly and the set of keys available to Byzantine machines are the same, any message generated by a new Byzantine machine could have been generated by an old one.

\david{Proof if there is forwarding.}
Now consider signed or nested type message channels where some parts of the message is forwarded (signed with the key of another machine).
If the key belongs to another Byzantine machine, then the same message could have been generated locally without forwarding, and our argument above holds.
If the key belongs to a correct machine, that machine must have sent a message $m$ to some Byzantine machine $l^1$, which forwarded the message along a chain of Byzantine machines until it arrived at Byzantine machine $l^i$, which then sent a message including the signature and protected fields from $m$.
Note that the forwarding chain can be of length zero such that $l^1 = l^i$, to represent no inter-machine forwarding; it can also contain multiple instances of the same machine.

\david{Conversion of run over rewritten protocol to run over original protocol.}
We will show that this run is possible in the original protocol as well.
We can ``undo'' the rewrites by replacing all new Byzantine machines with their corresponding old Byzantine machine: for example, partitions $l_1, l_2, \ldots$ created from machine $l$ are replaced with $l$.
The union of the received messages \texttt{msg\_store} in the new Byzantine machines then becomes the \texttt{msg\_store} of the corresponding old Byzantine machine.
Therefore, any message that the new Byzantine machine can forward could have been forwarded by an old Byzantine machine as well.

\david{Address nested messages that include new message types.}
One wrinkle in the argument above is that the correct machine may send messages meant for new or modified channels that it would not have sent in the original protocol.
These messages may then be nested into another message by a Byzantine machine and delivered to a preexisting message channel on a correct machine, if the typing is valid.
This can be avoided by including the message type as part of the message signature, so any incorrect message nesting results in an invalid signature.


\subsubsection{Equivalent number of failures}
\label{sec:equivalent-number-of-failures}
The decoupling or partitioning of a machine $l$ into many corresponding machines $l_1, l_2, \ldots$ does not increase the number of failures in the system.
As described in \sigmodpaper{}, the failure of any machine $l_i$ can be treated as a failure of $l$.
Each set of machines $l_i$ can be grouped into the same failure domain (that originally consisted of only $l$), so the rewrites increase the number of machines in each domain but not the number of possibly faulty domains.



\subsection{Modified channels enforce new invariants}
\label{sec:byzantine-new-channels}
Having shown that new Byzantine machines are not more powerful when it comes to sending messages to unmodified channels, we must now show that new or modified channels are resilient to Byzantine messages.
These modified channels have implicit invariants on the messages that they can receive, which are encoded by the rewrites on the ``senders'', the machines that send messages to these channels.
A Byzantine sender can choose to break the invariant, as illustrated in \Cref{sec:intro}. \david{If we make a figure, reference that instead.}

The new and modified channels' invariants can be grouped into three categories:
Internal routing (\Cref{sec:internal-routing}),
External routing (\Cref{sec:external-routing}), and
Duplication (\Cref{sec:duplication}).


\subsubsection{Internal routing}
\label{sec:internal-routing}



\subsubsection{External routing}
\label{sec:external-routing}
blah

\subsubsection{Duplication}
\label{sec:duplication}
blah